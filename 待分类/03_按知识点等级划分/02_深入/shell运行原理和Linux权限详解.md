---
title: shell运行原理和Linux权限详解
description: 
published: true
date: 2022-12-12T06:01:38.489Z
tags: 
editor: markdown
dateCreated: 2022-12-12T01:04:33.419Z
---

# shell运行原理和Linux权限详解
## 1. shell 命令以及运行原理

> Linux 严格意义上说的是一个操作系统，我们称之为 “核心（kernel）“ ，但我们一般用户，不能直接使用 kernel。而是通过 kernel 的“外壳” 程序，也就是所谓的 shell，来与 kernel 沟通。

**如何理解？为什么不能直接使用 kernel?**

> 从技术角度，Shell 的最简单定义：命令行解释器（command Interpreter）主要包含：

将使用者的命令翻译给核心（kernel）处理。
同时，将核心的处理结果翻译给使用者。

![2022-12-12_1681.png](/2022-12-12_1681.png)

> 注意：shell 是所有外壳程序的统称，bash 是一种具体的 shell。例如：centos 7 外壳程序 ：bash

- 对比 windows GUI，我们操作 windows 不是直接操作 windows 内核，而是通过图形接口，点击，从而完成我们的操作（比如进入 D 盘的操作，我们通常是双击 D 盘盘符. 或者运行起来一个应用程序）。
- 
- shell 对于 Linux，有相同的作用，主要是对我们的指令进行解析，解析指令给 Linux 内核。反馈结果在通过内核运行出结果，通过 shell 解析给用户。
- 
- shell 运行原理

shell是做命令行解释的
对系统有危害性的命令会被阻止从而保护操作系统
其好处为子进程出现任何问题都不会影响父进程shell


帮助理解：

如果说你是一个闷骚且害羞的程序员，那 shell 就像媒婆
操作系统内核就是你们村头漂亮的且有让你心动的 MM 小花。
你看上了小花，但是有不好意思直接表白，那就让你你家人找媒婆帮你提亲
所有的事情你都直接跟媒婆沟通，由媒婆转达你的意思给小花
而我们找到媒婆姓王，所以我们叫它王婆，它对应我们常使用的 bash。


## 2. Linux 权限

### 2.1 权限的概念
Linux 下有两种用户：超级用户（root）、普通用户。
超级用户：可以再 linux 系统下做任何事情，不受限制
普通用户：在 linux 下做有限的事情。
超级用户的命令提示符是 “#”，普通用户的命令提示符是 “$”。

![2022-12-12_91262.png](/2022-12-12_91262.png)

用户切换的命令

命令：su [用户名]

功能：切换用户。

> 例如，要从 root 用户切换到普通用户 user，则使用 su user。要从普通用户 user 切换到 root 用户则使用 suroot（root 可以省略），此时系统会提示输入 root 用户的口令。

![2022-12-12_44501.png](/2022-12-12_44501.png)

切换到 root：用 su -，我们可以切换到 root 用户（此时输入 root 账号密码，密码是不会回显在屏幕上的）

切换回普通用户：用 su - 用户名 切回普通用户，（此时不用输入密码，但是我们不建议这样切回，因为使用 su - 命令时，会创建更多的 bash 进程）

推荐的切换回普通用户：输入 exit 或者敲击 Ctrl+d，回退到普通用户

### 2.2 权限管理

什么是权限

> 权限本质上是决定某件事情，某人能否做。

针对事物：我想去吃一台电脑、我想在面包上玩英雄联盟、看电影。面包能吃，但是电脑不能吃、你可以吃面包，但是不能吃电脑；这里面包括了两个属性。

> 文件受人的影响和文件受本身自身特点 (事物属性) 的影响 所以文件权限 = 人 + 事物属性

文件权限属性：r(读)、w(写)、x(执行权限)
人 (不是特定具体的人，而是一种角色)：拥有者、所属组、other (其它）

文件访问者的分类（人）

文件和文件目录的所有者：u—User（中国平民 法律问题）

文件和文件目录的所有者所在的组的用户：g—Group（不多说）

其它用户：o—Others （外国人）
文件类型和访问权限（事物属性）

![2022-12-12_73508.png](/2022-12-12_73508.png)

> 使用命令 ls -l (ll) 显示的多列属性的第一列对应的字符来区分它的文件类型。

![2022-12-12_80367.png](/2022-12-12_80367.png)

>不需要列出 other，因为不是拥有者和所属组的就是 other 了

帮助理解 - 拥有者和所属组

我们举个简单的例子，在一家公司内部，两个项目组，要完成同样的代码任务，他们之间彼此是互相竞争的关系，但是公司给他们提供的服务器只有一个，他们完成的代码要提交上去，这是你写的代码，肯定只是想让你和你的组员组长能看到，不想你的竞争对手组看到，这就产生了所属组的概念。

![2022-12-12_77603.png](/2022-12-12_77603.png)

文件类型
d：文件夹
-：普通文件
l：软链接（类似 Windows 的快捷方式）
b：块设备文件（例如硬盘、光驱等）
p：管道文件
c：字符设备文件（例如屏幕等串口设备）
s：套接口文件

![2022-12-12_71424.png](/2022-12-12_71424.png)

基本权限
i. 读（r/4）：Read 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限
ii. 写（w/2）：Write 对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限
iii. 执行（x/1）：execute 对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限
iv.“—” 表示不具有该项权限

![2022-12-12_15165.png](/2022-12-12_15165.png)

### 2.3 文件权限值的表示方法

字符表示方法
![2022-12-12_52617.png](/2022-12-12_52617.png)

八进制数值表示方法
![2022-12-12_74502.png](/2022-12-12_74502.png)

![2022-12-12_42416.png](/2022-12-12_42416.png)

权限更改
```
$ chmod 777 text.c
$ chmod 000 text.c
$ chmod 640 text.c
```

![2022-12-12_64998.png](/2022-12-12_64998.png)

### 2.4 文件访问权限的相关设置方法
chmod
功能：设置文件的访问权限
格式：chmod [参数] 权限 文件名
常用选项：
R -> 递归修改目录文件的权限
说明：只有文件的拥有者和 root 才可以改变文件的权限
chmod 命令权限值得格式
① 用户表示符 +/-= 权限字符
+: 向权限范围增加权限代号所表示的权限
-: 向权限范围取消权限代号所表示的权限
=: 向权限范围赋予权限代号所表示的权限
用户符号：
u：拥有者
g：拥有者同组用
o：其它用户
a：所有用户
示例：

![2022-12-12_66097.png](/2022-12-12_66097.png)


> 注意：chmod 可以给拥有者，所属组，其他用户同时修改权限，中间用逗号隔开

> 如果要修改不是自己的文件的时候需要 sudo 临时权限提升或者直接切成 root 身份

sudo chmod 用户表示符 +/-= 权限字符 文件名
chown
功能：修改文件的拥有者
格式：chown [参数] 用户名 文件名
实例：

```
$ sudo chown root test.c// 修改拥有者
$ sudo chown lighthouse test.c// 修改拥有者
$ sudo chown :lighthouse test.c// 修改所属组
$ sudo chown lighthouse:lighthouse test.c// 可以将拥有者、所属组同时修改
$ sudo chown root:root test.c// 可以将拥有者、所属组同时修改
```
![2022-12-12_25128.png](/2022-12-12_25128.png)

chgrp
功能：修改文件或目录的所属组
格式：chgrp [参数] 用户组名 文件名
常用选项：-R 递归修改文件或目录的所属组
实例：

```
$ sudo chgrp root text.c
$ sudo chgrp lighthouse text.c
```

![2022-12-12_2506.png](/2022-12-12_2506.png)

2.4 修改文件的掩码
umask
功能：查看或修改文件掩码
语法：umask 权限值

![2022-12-12_2115.png](/2022-12-12_2115.png)

新建文件夹默认权限 = 0666
新建目录默认权限 = 0777

![2022-12-12_88459.png](/2022-12-12_88459.png)

>但是我们观察到，新建的文件和目录并不是默认的起始权限，这里是什么原因呢？

>原因就是创建文件或目录的时候还要受到 umask 的影响。假设默认权限是 mask，则实际创建的出来的文件权限是:umask & ~umask

![2022-12-12_81393.png](/2022-12-12_81393.png)


我们也可以通过修改文件的 umask 码值来修改文件的权限:


![2022-12-12_72380.png](/2022-12-12_72380.png)


说明：将现有的存取权限减去权限掩码后，即可产生建立文件时预设权限。超级用户默认掩码值为 0022，普通用户默认为 0002。
### 2.5 file 指令
file
功能说明：辨识文件类型。
语法：file [选项] 文件或目录…
常用选项：
-c 详细显示指令执行过程，便于排错或分析程序执行的情形。
-z 尝试去解读压缩文件的内容。

![2022-12-12_25164.png](/2022-12-12_25164.png)

目录权限
面试题：进入一个目录要什么权限？
可读权限: 如果目录没有可读权限,则无法用 ls 等命令查看目录中的文件内容.
可写权限: 如果目录没有可写权限,则无法在目录中创建文件, 也无法在目录中删除文件.
可执行权限：如果没有目录可执行权限，则无法 cd 到目录中

```
x
r
w
```

粘滞位

新发现：
> 就是只要用户具有目录的写权限, 用户就可以删除目录中的文件, 而不论这个用户是否有这个文件的写权限.我创建的一个文件, 凭什么被你一个外人可以删掉

![2022-12-12_37366.png](/2022-12-12_37366.png)


结论
如果目录本身对 other 具有 w 权限，other 可以删掉任何目录下的东西
如果目录本身对 other 没有 w 权限，other 则不可以删除
>我们的需求：other 可以在特定的目录下创建文件并写入，但是不想让任何人删除掉自己的文件

这里为了解决这个不科学的问题，Linux 引入了粘滞位的概念
粘滞位
语法：chmod +t 目录名
功能：给目录加上粘滞位
注意

>只能对目录设置，一般是限制 other权限的，对设置粘滞位的目录，在该目录下，只能有文件的拥有者和 root 用户可以删除，其他人不能删除

示例：

![2022-12-12_39921.png](/2022-12-12_39921.png)

有多个人或者系统会有很多的临时数据，所有的临时文件都放在系统的 /tmp 目录下。所有的权限需要放开，但是只想让文件的拥有者删除自己的文件，这需要设置粘滞位

### 总结

目录的可执行权限是表示你可否在目录下执行命令。
如果目录没有 - x 权限，则无法对目录执行任何命令，甚至无法 cd 进入目, 即使目录仍然有 - r 读权限（这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件）
而如果目录具有 - x 权限，但没有 - r 权限，则用户可以执行命令，可以 cd 进入目录。但由于没有目录的读权限
所以在目录下，即使可以执行 ls 命令，但仍然没有权限读出目录下的文档。


