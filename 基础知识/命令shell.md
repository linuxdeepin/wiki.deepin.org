---
title: 命令shell
description: 
published: true
date: 2022-05-07T07:49:27.977Z
tags: 
editor: markdown
dateCreated: 2022-04-21T03:47:05.705Z
---

## 简介

文字操作系统与外部最主要的接口就叫做shell。shell是操作系统最外面的一层。 shell管理你与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。

shell提供了你与操作系统之间通讯的方式。这种通讯可以以交互方式（从键盘输入，并且可以立即得到响应），或者以shell script(非交互）方式执行。

shell script是放在文件中的一串shell和操作系统命令，它们可以被重复使用。本质上，shell script是命令行命令简单的组合到一个文件里面。

Shell基本上是一个命令解释器，类似于DOS下的command.com。它接收用户命令（如ls等），然后调用相应的应用程序。

## 种类

绝大多数 Linux 都不仅仅只支持一种 Shell,如果想要知道当前深度操作系统支持的命令shell,终端执行:

    cat /etc/shells
    # /etc/shells: valid login shells
    /bin/sh
    /bin/dash
    /bin/bash
    /bin/rbash

这样会发现系统有多个Shell 可供使用,每个 Shell 都有自己的一些特点,其中比较常用的有 bash。

- bash

所在文件名:/bin/bash

特性:
1.由自由软件基金会(FSF)开发,遵循 POSIX 标准

2.是默认的 Shell,支持命令历史,别名等操作

3.强大的 Shell 脚本功能

- ksh

所在文件名:/usr/bin/ksh

特性:是 Bsh 的高级扩展,默认提示符是$

## 功能

命令shell基础功能有以下几个:

- 命令补齐

由于 Shell 主要是基于命令行操作的,所以绝大多数时间是在用键盘进行输入的,但有时候可能会碰到一些比较长的命令,输入起来并不方便,此时就可以使用 Shell 提供的命令补齐功能,它能够输入命令前面的一部分,然后按下 Tab 键,后半部分 Shell 自动补齐。

- 路径补齐

与命令补齐类似,输入路径前面的一部分,然后按下 Tab 键,后半部分 Shell 自动补齐。

- 命令历史功能

如果有时需要输入刚输入的命令,而此命令又比较长的话,这时就可以使用 Shell 提供的命令历史功能。我们可以使用上下箭头键来显示曾经下达的指令,这样在命令行上就显示了最近输入的命令。如果命令下达的时间比较长的话,可以使用 history 命令来进行查看所有输入的命令,history 命令的格式如下:

    # history [-c | -n]

history 命令常见的选项有两个:

- -c: 清除当前 Shell 里的全部 history 内容。
- -n: 列出前 n 条命令。

当成功退出系统后,Shell 会将 history 中的内容写入当前登录用户的宿主目录中的.bash_history 文件中,也可以通过此文件来查看上一个用户都执行了哪些操作。(在此要提醒一下,以后涉及一些可以在命令行上输密码的连线服务或者程序时,尽量不要在命令行上输入密码,因为如果疏忽的话很可能在此文件中将密码泄露)。

- 命令别名功能

如果经常重复性地输入同一个长命令,那么前面两个方法还是显得麻烦了些,其实 Shell 可以让我们使用一些比较简单或者有意义的单词来代替一个长命令(听起来比较像变量的定义),这就是为命令定义一个别名。
在 Shell 里定义命令别名的命令是 Alias,其使用方法如下:

    alias 别名=“原命令”

需要说明的是,在等号两端不要有空格,并且原命令最好使用引号括起来,因为 Shell 是以空格为单位区分命令和参数的,如果不加引号的话,很容易发生错误。

例如,安装了 www 服务后,它启动程序的路径在/usr/src/apache/bin 下,可以为其定义别名,以后直接使用别名就行了,可以如下方式操作:

    alias apache="/usr/src/apache/bin/apachectl start"

可以使用 alias 命令查看是否设置成功。如果成功,可以使用apache 命令直接启动 Apache 服务了,直接在命令行执行:

    apache

你会发现结果和执行“/usr/src/apache/bin/apachectl start”命令是一样的。 但是此次只是当前登录期间有效,如果退出系统别名就会失效了,如果想让其永久生效的话,可以将上面的别名定义写进管理员的宿主目录(就是/etc/passwd 文件中第 5 列规定的目录),这样每次登录都可以使用此别名了。

其实,Ubuntu 默认已经设置好了一些命令别名,大家还记得在前面介绍 ls 命令的时候,曾经提到过执行 ls 命令时,以颜色来判断文件的类型并不是绝对正确的,可以通过 alias 命令来查看原因:

    $ alias
    alias ls="ls –color=auto"

取消一个命令别名也很容易,只需要执行命令:

    unalias 命令别名

这样再使用 alias 命令查看的话就会发现别名已经删除了,当然如果以前已经写在配置文件中了,也要将文件中的别名定义去掉。

## 特殊符号

在shell中常用的特殊符号罗列如下:

         # ; ;; . , / \ 'string'| ! $ ${} $? $$ $*
         string"* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || &&
         {xx,yy,zz,...}~ ~+ ~- & \<...\> + - %= == != 

### 井号 (comments)

这几乎是个满场都有的符号，除了先前已经提过的"第一行"

           #!/bin/bash

井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。

          # This line is comments.
         echo "a = $a" # a = 0

由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。

          #echo "a = $a" # a = 0

如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。

### ~ 帐户的 home 目录

算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin

 ~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。

         # echo ~+/var/log

~-上次的工作目录，这个符号代表上次的工作目录。

          # echo ~-/etc/httpd/logs

### ; 分号 (Command separator)

在 shell 中，担任"连续指令"功能的符号就是"分号"。譬如以下的例子：

          cd ~/backup ; mkdir startup ;cp ~/.* startup/

### ;; 连续分号 (Terminator)

专用在 case 的选项，担任 Terminator 的角色。

    case "$fop" in
        help)
            echo "Usage: Command -help -version filename"
            ;;
        version)
            echo "version 0.1"
            ;;
    esac

### . 逗号 (dot,就是“点”)

在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。

          CDPATH=.:~:/home:/home/web:/var:/usr/local

在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。 如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。

### 'string' 单引号 (single quote)

被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。

    heyyou=home
    echo '$heyyou' # We get $heyyou

### "string" 双引号 (double quote)

被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。

    heyyou=home
    echo "$heyyou" # We get home

`command` 倒引号 (backticks)

在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。

    fdv=`date +%F`
    echo "Today $fdv"

在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。

#### , 逗点 (comma，标点中的逗号)

这个符号常运用在运算当中当做"区隔"用途。如下例

    #!/bin/bash
    let "t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))"
    echo "t1= $t1, a = $a, b = $b"

#### / 斜线 (forward slash)

在路径表示时，代表目录。

    cd /etc/rc.d
    cd ../..
    cd /

通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。

          let "num1 = ((a = 10 / 2, b = 25 / 5))"

### \ 倒斜线

在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。

    $ type rm
    rm is aliased to `rm -i'
    $ \rm ./*.log

上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。

    $ bkdir=/home
    $ echo "Backup dir, \$bkdir = $bkdir"
    Backup dir,$bkdir = /home

上例 echo 内的 \$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。

### | 管道 (pipeline)

pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。

          who | wc -l

善用这个观念，对精简 script 有相当的帮助。

### ! 惊叹号(negate or reverse)

通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表"不等于"

    if [ "$?" != 0 ]; then
        echo "Executes error"
        exit 1
    fi

在规则表达式中她担任 "反逻辑" 的角色

          ls a[!0-9]

上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。

### : 冒号

在 bash 中，这是一个内建指令："什么事都不干"，但返回状态值 0。

         :
         echo $? # 回应为 0
          : > f.$$

上面这一行，相当于 cat /dev/null >f.$$。不仅写法简短了，而且执行效率也好上许多。 有时，也会出现以下这类的用法

          : ${HOSTNAME?} ${USER?} ${MAIL?}

这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。 除了上述之外，还有一个地方必须使用冒号

          PATH=$PATH:$HOME/fbin:$HOME/fperl:/usr/local/mozilla

在使用者自己的HOME 目录下的 .bash_profile或任何功能相似的档案中，设定关于"路径"的场合中，我们都使用冒号，来做区隔。

### ? 问号 (wild card)

在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。

          # ls a?a1

善用她的特点，可以做比较精确的档名匹配。

### *星号 (wild card)

相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。

          # ls a*a a1 access_log

在运算时，它则代表 "乘法"。

          let "fmult=2*3"

除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任"乘法"的角色。不过在使用上得小心，他的前面必须加上escape 字元。

两个星号在运算时代表 "次方" 的意思。

    let "sus=2**3"
    echo "sus = $sus" # sus = 8

### $ 钱号(dollar sign) 变量替换(Variable Substitution)的代表符号。 vrs=123echo "vrs = $vrs" # vrs = 123 另外，在 Regular Expressions 里被定义为 "行" 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中

${} 变量的正规表达式

bash 对 ${} 定义了不少用法。以下是取自线上说明的表列

           ${parameter:-word}   ${parameter:=word}   ${parameter:?word}   ${parameter:+word}     ${parameter:offset}   ${parameter:offset:length}   ${!prefix*}                              ${#parameter}   ${parameter#word}   ${parameter##word}   ${parameter%word}   ${parameter%%word}   ${parameter/pattern/string}                     ${parameter//pattern/string}

### $*

$* 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：

          $0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}.....

个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。 $* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。

          echo "$*"

还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。

### $@

$@ 与 $*具有相同作用的符号，不过她们两者有一个不同点。 符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。
### $ #

这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。

          echo "$#"

### $? 状态值 (status variable)

一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。 一般指令程序倘若执行成功，其回传值为 0；失败为 1。

    tar cvfz dfbackup.tar.gz /home/user > /dev/null
    echo"$?"$$

由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号$$或许可以符合这种需求。它代表当前shell 的 PID。 echo "$HOSTNAME, $USER, $MAIL" > ftmp.$$ 使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。 ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。

### ( ) 指令群组 (command group)

用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子

    $ cat ftmp-01
    #!/bin/bash
    a=fsh(a=incg ; echo -e "\n $a \n")
    echo $a
    $ ./ftmp-01
    incgfsh

除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。

### (( ))

这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。

    #!/bin/bash
    (( a = 10 ))
    echo -e "inital value, a = $a\n"
    (( a++))
    echo "after a++, a = $a"

### { } 大括号 (Block of code)

有时候 script 当中会出现，大括号中会夹着一段或几段以"分号"做结尾的指令或变数设定。

         cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e "\n $a \n"}echo $a#./ftmp-02inbcinbc

这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。 大括号也被运用在 "函数" 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。

此外，大括号还有另一种用法，如下

     {xx,yy,zz,...}

这种大括号的组合，常用在字串的组合上，来看个例子 mkdir {userA,userB,userC}-{home,bin,data} 我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子 chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}} 如果不是因为支援这种用法，我们得写几行重复几次呀！

### [ ] 中括号

常出现在流程控制中，扮演括住判断式的作用。if [ "$?" != 0 ]thenecho "Executes error"exit1fi 这个符号在正则表达式中担任类似 "范围" 或 "集合" 的角色

          rm -r 200[1234]

上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。

### [[ ]]

这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&& 逻辑等符号。

    #!/bin/bash
    read ak
    if [[ $ak > 5 || $ak< 9 ]]; then
        echo $ak
    fi

### || 和 &&

这个会时常看到，|| 代表 or 逻辑运算符，&& 代表 and 逻辑运算符。

### & 后台工作

单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。

          tar cvfz data.tar.gz data > /dev/null&

### \<...\> 单字边界

这组符号在规则表达式中，被定义为"边界"的意思。譬如，当我们想找寻 the 这个单字时，如果我们用 grep the FileA 你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 "边界" 的符号 grep '\' FileA

### + 加号 (plus)

在运算式中，她用来表示 "加法"。

          expr 1 + 2 + 3

此外在规则表达式中，用来表示"很多个"的前面字元的意思。

    $ grep '10\+9' fileB
    109
    1009
    100009
    1000093
    1010009

这个符号在使用时，前面必须加上escape 字元。

### - 减号 (dash)

在运算式中，她用来表示 "减法"。

          expr 10 - 2

此外也是系统指令的选项符号。

          ls -expr 10 - 2

在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表"标准输入"的意思。这是 GNU指令的共通选项。譬如下例

          tar xpvf -

这里的 - 符号，既代表从标准输入读取资料。 不过，在 cd 指令中则比较特别

          cd -

这代表变更工作目录到"上一次"工作目录。

### % 模 (Modulo)

在运算式中，用来表示 "除法"。

    expr 10 % 2

此外，也被运用在关于变量的规则表达式当中：

    ${parameter%word}
    ${parameter%%word}

一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。

### = 等号 (Equals)

常在设定变数时看到的符号。 vara=123echo " vara = $vara" 或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。

### == 等号 (Equals)

常在条件判断式中看到，代表 "等于" 的意思。

    if [ $vara == $varb ] ...下略

### != 不等于

常在条件判断式中看到，代表 "不等于" 的意思。

     if [ $vara != $varb ] ...下略

### ^ 脱字符

这个符号在规则表达式中，代表行的 "开头" 位置，在[]中也与"!"(叹号)一样表示“非”

### 输出/输入重导向

 >      >>   <   <<   :>   &>   2&>   2<>>&   >&2   

文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。 常用的文件描述符如下：

| 文件描述符 | 名称 | 常用缩写 | 默认值 |
| :------: | :------: | :------: | :------: |
| 0 |            标准输入      |  stdin      |         键盘 |
| 1  |             标准输出    |  stdout   |         屏幕 |
| 2 |           标准错误输出 |  stderr  |        屏幕 |

我们在简单地用<或>时，相当于使用 0< 或 1>（下面会详细介绍）。

#### cmd > file

把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。

#### cmd >> file

把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。

#### cmd < file

使cmd命令从file读入

#### cmd << text

从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用"<<-text" ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。

#### cmd <<< word

把word（而不是文件word）和後面的换行作为输入提供给cmd。

#### cmd <> file

以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。

#### cmd >| file

功能同>，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用>!实现这一功能。

#### > filename

把文件"filename"截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).

#### cmd >&n

把输出送到文件描述符n

#### cmd m>&n

把输出 到文件符m的信息重定向到文件描述符n

#### cmd >&-

关闭标准输出

#### cmd <&n

输入来自文件描述符n

#### cmd m<&n

使m来自文件描述符 n

#### cmd <&-

关闭标准输入

#### cmd <&n-

移动输入文件描述符n而非复制它，即在复制n到cmd后关闭当前shell 中原有的n。

#### cmd >&n-

移动输出文件描述符 n而非复制它，即在复制n到cmd后关闭当前shell 中原有的n。

 注意： >&实际上复制了文件描述符，这使得

    cmd > file 2>&1

与

    cmd 2>&1 >file

的效果不一样。

## 变量

要想深入地了解 Shell 和熟练地使用 Shell 进行管理,仅仅知道以上的一些优点是不够的,下面介绍 Shell 的一个重要组成部分——变量。
变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，比如临时文件夹位置和系统文件夹位置等。

### 种类

Shell 中的变量分为以下几种:

(1)局部变量:只在一定范围内能够使用的变量,只在设定此变量的 Shell 中有效。

(2)环境变量:在整个系统环境中都能够使用,不但在设定此变量的 Shell 中有效,而且在所有由此 Shell 所衍生出的子 Shell 中都有效。

(3)位置变量:主要用于记录命令及其选项值的变量,是只读的。

(4)特殊形式的变量:主要记录一些特殊值的变量,是只读的。

### 类型和系统配置文件

Shell 按类型分可以分为父 Shell、子Shell,或者是登录 Shell 和非登录 Shell。

当成功登录后所获得的 Shell 叫做登录 Shell,而在以后打开的所有 Shell 都叫做非登录 Shell,例如可以在命令行中执行命令:

          bash

这样就会又打开一个 Shell,只是此 Shell 已经是在前一个 Shell中又执行了一个程序(/bin/bash)的结果了,所有执行的命令都是在此Shell 中执行的,而与前一个 Shell 无关,如果要回到上一个 Shell,那么只需退出此 Shell(或者说/bin/bash 程序),执行命令:

          exit

这样就可以回到上一层 Shell,将上一层 Shell 叫做父 Shell,将由父 Shell 中打开的 Shell 叫做子 Shell。子 Shell 会继承父 Shell 的工作环境,包括当前工作目录、进程权限等。

由此可以看出:登录 Shell 只有一个,而非登录 Shell 可以有多个; 而任何一个 Shell 都可能是另一个 Shell 的父 Shell,登录 Shell 永远不可能是子 Shell。

子 Shell 和父 Shell 其实比较好理解,只是在一个程序(/bin/bash)中又执行了一个程序(/bin/bash)而已,而二者即形 成父 Shell 和子 Shell 的关系,那么登录 Shell 和非登录 Shell 的本质区别是什么呢?

在此先简单地介绍几个系统的配置文件,通过 Shell 对这几个配置文件的读取情况来分析一下二者的区别。

(1)./etc/bash.bashrc:系统的环境的设定文件,设定了一些环境变量和命令行提示符。

(2)/etc/profile:系统的启动脚本文件,也是对系统环境进行了设定。

(3)~/.bashrc:当前登录用户的宿主目录下的配置文件,对用户的个性化环境进行单独设定,设定了用户的别名等。

(4)~/. profile:当前登录用户的初始化文件。

可以看到,前两个/etc/目录下的文件是对整体的环境进行设定的,而后面的两个文件只是对当前登录用户来设定的,换句话说,就是/etc目录下的两个设定文件无论是哪个用户登录进来都会读取一遍设定,而读取完了这些系统文件后,用户才读取每个用户宿主目录下都有的,只有自己才能读取的那两个文件。

了解了这几个文件后,我们回过头来看一下登录 Shell 和非登录Shell,实际上它们的区别正是与这几个文件有关,对于登录 Shell 来说,它会先读取/etc 目录下的两个文件里的所有设定,然后去用户的宿主目录下再读取一下.bashrc 和.profile 文件,而对于非登录 Shell来说,每打开一个非登录 Shell,它只读取.bashrc 和/etc/bash.-bashrc 文件而不再去读取/etc/profile 和.profile 文件这两个初始化文件了。

下面举例来说明二者区别(只以/etc/bash.bashrc 和/etc/pro-file 文件为例)。 先在/etc/bash.bashrc 文件最下面添上如下内容:

          alias cls=’clear”

然后保存退出,执行如下命令:

          cls

会发现别名并未生效,系统提示未发现命令,这是因为此时在登录Shell 中,它已经在登录过程中读取完了此文件的配置,否则不会再去读取此文件,再执行 bash 命令打开一个非登录 Shell 后执行命令:

          cls

我们会发现别名已经生效。这是因为非登录 Shell 会重新读取一下。

接下来删除/etc/bash.bashrc 文件中的别名,并将其添加/etc/profile 文件中,退出系统后按刚才步骤依此执行后会发现,无论是登录 Shell 还是非登录 Shell,执行 cls 命令都提示命令未发现。

由此可见,登录 Shell 和非登录 Shell 的区别就是执行时读取的文件不完全相同。登录 Shell 所有文件全部读取,而非登录 Shell 并不读取初始化文件。

### 变量的定义及显示

无论是系统变量还是局部变量,设定的方法都是一样的,只是使]用的范围不同而已。

1. 定义变量

在 Shell 中定义一个变量比较简单,比如现在想定义一个 name 变量并且给它赋值为“ubuntu”,则可以进行如下操作:
          name=”ubuntu”

这样就定义好了一个变量,需要注意的是:

(1)定义变量的时候需要用“=”连接,并且等号两边不能有空格。

(2)左边是变量名,右边是变量的值,变量的名只能是字母,数字或者下划线,并且不能用数字开头。

(3)在一般情况下,用户自定义的变量一般都小写,而系统变量一般都大写

2. 显示变量的值

设定好了一个变量后,可以使用 echo 命令显示它的值:

          echo $name
         ubuntu

其中 echo 命令是用来显示一个变量或者字符串的值,而“$”符号在这里有特殊的含义,意为“取变量的值”,即由“$name”先把变量name 的值取出来,然后由“echo”命令将其显示在屏幕上。

3.使用 export 命令导出变量 由上一章节可以知道,此时所设的 name 变量是个局部变量,它只是在当前的 Shell 中是有效的,如果执行 bash 命令打开一个子 Shell中的话,则无法使用该变量了:

          echo $name

--- 显示变量值为空

而如果想使变量永久生效或者是所有用户都能够使用该如何设定?请读者朋友根据上一节的内容思考一下。 如果此 name 变量只是个临时变量,那么只能在当前的 Shell 中使用它,但是还想在子 Shell 中能够使用怎么办呢?可以使用 export 命令完成。export 命令将在当前 Shell 中设定的变量在以后所有此 Shell的子 Shell 中都能够使用。还是以刚才的 name 变量为例,在设定 name变量时直接使用如下命令:

          export
         name=”ubuntu”

这样再执行 bash 命令后,在子 Shell 中就可以使用 name 变量了。

4. 取消变量

变量是要占用一定的内存空间的,所以对于不使用的变量要将它取消,可以使用 unset 命令:

          unset name

这样,当再次使用 echo 命令查看时候就显示为空了。

5. 环境变量的使用 环境变量的定义方法与局部变量是一样的,它们也可以称为全局变量,可以使用 export 命令使其在子 Shell 中使用。但要注意,在一个父 Shell 中可以使用 export 命令导出一个变量给子 Shell 使用,可如果要在子 Shell 中定义一个变量,即使用 export 命令导出了,它也不能在父 Shell 中使用,而只能向下一个子 Shell 中传递,也就是说这是个单向的过程。

### 位置变量

经过一段时间的使用,读者想必已经熟悉了 Shell 命令的下达方式

 命令名[选项] 参数1  参数2

不知道大家想没想过一点,每次都是传递的不同的参数,为什么命令能够根据分辨出不同的参数和选项来执行相应的操作呢?知道Shell 是可以编写脚本程序的,它能不能也做到这一点呢?答案是肯定的,可以通过使用位置变量来完成,虽然它与 Shell 中的那些二进制命令有一些差别。

Shell 为我们定义了一些特殊的变量,这些变量主要就是用来记录编写的脚本程序名和需要传递给脚本程序的参数的,这些变量叫做位置变量。

Shell 中的位置变量是由它们在作为参数向脚本程序传递过程中的位置不同而区分的,这些位置变量是只读的,名字不能被更改,Shell的位置变量

         变量写法 含义
         $0 表示的执行的程序名,如上面例子中的 sum.sh
         $(1-9) 这个代表的是传给程序的参数,分别为$1 至$9
         ${大于 9 的数字} 这个含义同上,只是如果位置数要是大于 9 的话,应该用{}将数字括起

### 特殊形式的变量

Shell 不但提供了位置变量,而且还提供很多的特殊变量,这些变量与位置变量一样都是不可变的,这些变量都是由单个字符组成的,这些变量有的与位置变量有关,有的与 Shell 或者命令有关.

         变量写法 含义
         $# 代表位置变量的个数
         $* 代表所有的位置变量
         $@ 如果不加“”的话,那么作用与$*相同,如果表示为“$@”,则表示的每个位置变量的值。
         $$ 表示当前 Shell 的 PID(进程的 IP 号)的值
         $? 最近一个执行过的命令的退出值

### 命令的执行顺序
有时候执行一个命令时,需要另一个命令执行成功(或者是失败)以后才可以进行。例如,想将/home/test 目录移动 到/home/ubuntu/bak 目录中,再将/home/test 目录删除,这样确保目录移动成功后才删除原文件,或者需要添加一个用户,但首先确认这个用户得不存在才可以,所以先用 grep 命令在/etc/passwd 文件查找一下,如果命令失败才可以执行添加用户的命令,这些都与命令执行的先后顺序有关。命令的执行顺序如下所示:

- 如果一个命令执行成功后才可以执行另一个命令可以使用“&& ” 来完成。
- 如果一个命令执行失败后才可以执行另一个命令可以使用“|| ”来完成。
- 如果需要连续的执行一组命令,可以使用“;”来完成。

下面举例来说明它们的用法。 以上面的移动目录的例子来看一下“&&”的用法,可以执行以下 命令:

          sudo mv /home/test  /home/ubuntu/bak  && sudo  rm –rf /home/test

这样如果没有移动成功的话,后面的删除命令也不会执行,而必须mv 命令成功执行后才可以执行 rm 命令。

下面来看一下“||”的用法,以前面提到的添加用户为例:

          grep “user1”  /etc/passwd   || sudo useradd –d  /home/user1 –m user1

这样,如果系统里面没有 user1 用户的话才会建立此用户,否则不会执行建立用户 user1 的命令。 如果希望能够同时在命令行下达多个命令的话,就需要用到“;”,如:

          sudo mkdir /home/bak ; cd /home/bak ;sudo passwd.tar.gz /etc/passwd /etc/group tar czvf /etc/passwd /etc/group

在此例子中,先是建立了一个目录/home/bak,然后进入到此目录中,最后在此目录中对文件/etc/passwd 和/etc/group 文件进行了备份。可以看到,所有命令其实可以一步一步地完成,但是使用了“;”号 后,一行就可以执行了。

### 命令替换

有时候给变量赋值时,需要把一个命令的执行结果赋给变量,这就需要用到命令替换的功能,可以使用“``”(为~同一个键上的符号)来完成。例如希望将当前的 Ubuntu 的内核版本赋予一个变量,然后将变量显示出来,可以下达命令:

           kernel_version=`uname –r` && echo $kernel_version

这样就可以保存命令 uname –r 的值了。命令替换在编写 Shell 脚本时会经常用到。

## 相关链接

[来源_balaamwe博客:linux特殊符号大全](http://www.cnblogs.com/balaamwe/archive/2012/03/15/2397998.html)
